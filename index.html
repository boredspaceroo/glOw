<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Flow</title>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
    body {
        background: white;
        overflow: hidden;
        touch-action: none;
        font-family: 'Oxanium', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    
    canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }
    
    #score {
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 22px;
        font-weight: 600;
        color: #666;
        z-index: 10;
        letter-spacing: 1px;
    }
</style>
```

</head>
<body>
    <div id="score">SCORE: 0</div>
    <canvas id="gameCanvas"></canvas>

```
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    
    // Set canvas size
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Game state
    const game = {
        targetX: canvas.width / 2,
        targetY: canvas.height / 2,
        bubbles: [],
        foods: [],
        waves: [],
        score: 0,
        difficulty: 1
    };
    
    // Shockwave class
    class Shockwave {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.radius = 0;
            this.maxRadius = Math.max(canvas.width, canvas.height) * 1.5;
            this.speed = 8;
            this.life = 100;
        }
        
        update() {
            this.radius += this.speed;
            this.life--;
            return this.life > 0 && this.radius < this.maxRadius;
        }
        
        draw() {
            const progress = this.radius / 100;
            let color, lineWidth;
            
            if (progress < 0.3) {
                color = '#DC143C'; // Red
                lineWidth = 3;
            } else if (progress < 0.6) {
                color = '#FFD700'; // Yellow
                lineWidth = 2.5;
            } else {
                color = '#999'; // Grey
                lineWidth = 2;
            }
            
            const alpha = Math.max(0, 1 - progress);
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        isRed() {
            return this.radius < 30;
        }
    }
    
    // Creature class
    class Creature {
        constructor() {
            this.segments = [];
            this.mainUnits = 1;
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.angle = 0;
            this.speed = 2.5;
            this.antennaeLength = 0;
            this.antennaeWave = 0;
            this.movementBubbles = [];
            this.finWave = 0;
            this.successBubbles = [];
            
            this.initializeSegments();
        }
        
        initializeSegments() {
            this.segments = [];
            const spacing = 18;
            
            // Build segments based on main units
            let offset = 0;
            for (let i = 0; i < this.mainUnits; i++) {
                // Main circle
                const isSpecial = i >= 2 && i <= 3 && this.mainUnits >= 4;
                this.segments.push({
                    x: this.x - offset,
                    y: this.y,
                    radius: 10,
                    type: isSpecial ? 'special' : 'normal',
                    targetX: this.x - offset,
                    targetY: this.y,
                    flashTime: 0,
                    isNew: false,
                    hasFins: isSpecial
                });
                offset += spacing;
                
                // Add tiny connector if not last
                if (i < this.mainUnits - 1) {
                    this.segments.push({
                        x: this.x - offset,
                        y: this.y,
                        radius: 4,
                        type: 'tiny',
                        targetX: this.x - offset,
                        targetY: this.y,
                        flashTime: 0,
                        isNew: false
                    });
                    offset += spacing * 0.5;
                }
            }
        }
        
        update(targetX, targetY) {
            const dx = targetX - this.x;
            const dy = targetY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 3) {
                this.angle = Math.atan2(dy, dx);
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
            
            this.segments[0].targetX = this.x;
            this.segments[0].targetY = this.y;
            
            for (let i = 0; i < this.segments.length; i++) {
                const segment = this.segments[i];
                
                segment.x += (segment.targetX - segment.x) * 0.18;
                segment.y += (segment.targetY - segment.y) * 0.18;
                
                if (i < this.segments.length - 1) {
                    const angle = Math.atan2(segment.y - this.segments[i + 1].y, 
                                             segment.x - this.segments[i + 1].x);
                    const spacing = segment.type === 'tiny' ? 9 : 18;
                    this.segments[i + 1].targetX = segment.x - Math.cos(angle) * spacing;
                    this.segments[i + 1].targetY = segment.y - Math.sin(angle) * spacing;
                }
                
                if (segment.flashTime > 0) {
                    segment.flashTime--;
                    if (segment.flashTime === 0) segment.isNew = false;
                }
            }
            
            this.antennaeWave += 0.08;
            this.finWave += 0.08;
            
            if (this.mainUnits >= 3) {
                this.antennaeLength = Math.min(30, (this.mainUnits - 2) * 6);
            }
            
            if (distance > 3 && Math.random() < 0.2) {
                this.movementBubbles.push({
                    x: this.x + (Math.random() - 0.5) * 15,
                    y: this.y + (Math.random() - 0.5) * 15,
                    radius: Math.random() * 2 + 1,
                    life: 25
                });
            }
            
            this.movementBubbles = this.movementBubbles.filter(b => {
                b.life--;
                b.y -= 0.4;
                return b.life > 0;
            });
            
            this.successBubbles = this.successBubbles.filter(b => {
                b.life--;
                b.y -= 0.8;
                b.x += b.vx;
                return b.life > 0;
            });
        }
        
        grow() {
            if (this.mainUnits < 10) {
                this.mainUnits++;
                this.initializeSegments();
                
                // Flash new segments
                const newSegmentsStart = this.segments.length - (this.mainUnits === 10 ? 2 : 3);
                for (let i = newSegmentsStart; i < this.segments.length; i++) {
                    this.segments[i].isNew = true;
                    this.segments[i].flashTime = 30;
                }
            }
            
            const points = this.mainUnits >= 10 ? 100 : 50;
            game.score += points;
            scoreEl.textContent = `SCORE: ${game.score}`;
            
            // Success bubbles for max form
            if (this.mainUnits >= 10) {
                for (let i = 0; i < 5; i++) {
                    this.successBubbles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 2,
                        radius: Math.random() * 3 + 2,
                        life: 40,
                        color: Math.random() < 0.5 ? '#90EE90' : '#FFD700'
                    });
                }
            }
            
            this.updateDifficulty();
        }
        
        shrink() {
            if (this.mainUnits > 1) {
                this.mainUnits--;
                this.initializeSegments();
                this.updateDifficulty();
            }
        }
        
        updateDifficulty() {
            game.difficulty = Math.max(1, Math.min(5, Math.floor(this.mainUnits / 2) + 1));
        }
        
        draw() {
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1.2;
            
            // Draw body segments
            for (let i = this.segments.length - 1; i >= 1; i--) {
                const segment = this.segments[i];
                
                if (segment.isNew && segment.flashTime > 0) {
                    const alpha = (segment.flashTime % 10) / 10;
                    ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (segment.type === 'special') {
                    // Special segment with blue center
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#4169E1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1.2;
                    
                    // Draw fins
                    if (segment.hasFins) {
                        const angle = Math.atan2(this.segments[0].y - segment.y, 
                                                 this.segments[0].x - segment.x);
                        const finLength = 20;
                        const wave = Math.sin(this.finWave + i) * 0.3;
                        
                        // Top fin
                        ctx.beginPath();
                        ctx.moveTo(segment.x, segment.y);
                        const fx1 = segment.x + Math.cos(angle + Math.PI/2 + wave) * finLength;
                        const fy1 = segment.y + Math.sin(angle + Math.PI/2 + wave) * finLength;
                        ctx.lineTo(fx1, fy1);
                        ctx.stroke();
                        
                        // Bottom fin
                        ctx.beginPath();
                        ctx.moveTo(segment.x, segment.y);
                        const fx2 = segment.x + Math.cos(angle - Math.PI/2 - wave) * finLength;
                        const fy2 = segment.y + Math.sin(angle - Math.PI/2 - wave) * finLength;
                        ctx.lineTo(fx2, fy2);
                        ctx.stroke();
                    }
                } else if (segment.type === 'tiny') {
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Draw antennae
            if (this.antennaeLength > 0) {
                const head = this.segments[0];
                const wave = Math.sin(this.antennaeWave) * 0.15;
                
                const angles = [this.angle + Math.PI/4, this.angle - Math.PI/4];
                const waves = [wave, -wave];
                
                angles.forEach((baseAngle, idx) => {
                    ctx.beginPath();
                    ctx.moveTo(head.x, head.y);
                    const ax = head.x + Math.cos(baseAngle + waves[idx]) * this.antennaeLength;
                    const ay = head.y + Math.sin(baseAngle + waves[idx]) * this.antennaeLength;
                    ctx.lineTo(ax, ay);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(ax, ay, 2.5, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }
            
            // Draw crescent head
            const head = this.segments[0];
            ctx.beginPath();
            ctx.arc(head.x, head.y, 15, this.angle - Math.PI * 0.55, this.angle + Math.PI * 0.55);
            ctx.stroke();
            
            // Draw movement bubbles
            ctx.lineWidth = 0.8;
            this.movementBubbles.forEach(bubble => {
                ctx.globalAlpha = bubble.life / 25;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Draw success bubbles
            this.successBubbles.forEach(bubble => {
                ctx.globalAlpha = bubble.life / 40;
                ctx.strokeStyle = bubble.color;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = '#999';
            });
            
            ctx.globalAlpha = 1;
            ctx.lineWidth = 1.2;
        }
        
        getHeadPosition() {
            return { x: this.segments[0].x, y: this.segments[0].y };
        }
        
        checkWaveCollision(wave) {
            if (!wave.isRed()) return false;
            
            for (let segment of this.segments) {
                const dx = wave.x - segment.x;
                const dy = wave.y - segment.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (Math.abs(dist - wave.radius) < 15) {
                    return true;
                }
            }
            return false;
        }
    }
    
    // Food class
    class Food {
        constructor() {
            this.x = Math.random() * (canvas.width - 100) + 50;
            this.y = Math.random() * (canvas.height - 100) + 50;
            this.targetX = this.x;
            this.targetY = this.y;
            this.angle = Math.random() * Math.PI * 2;
            this.moveTimer = 0;
            this.trianglePhase = 0;
            
            // Pulse mechanics
            this.pulsePhase = 0;
            this.pulseSpeed = 0.03 + (game.difficulty - 1) * 0.015;
            this.maxPulse = Math.PI * 2 * (3 - game.difficulty * 0.3);
            this.isExploding = false;
            this.explosionBubbles = [];
            this.explosionProgress = 0;
        }
        
        update() {
            if (this.isExploding) {
                this.explosionProgress++;
                
                if (this.explosionProgress === 1) {
                    // Create explosion bubbles
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        this.explosionBubbles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * 3,
                            vy: Math.sin(angle) * 3,
                            radius: Math.random() * 3 + 2,
                            life: 30
                        });
                    }
                    
                    // Create shockwave
                    game.waves.push(new Shockwave(this.x, this.y));
                }
                
                // Update explosion bubbles
                this.explosionBubbles.forEach(bubble => {
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    bubble.life--;
                    bubble.vx *= 0.95;
                    bubble.vy *= 0.95;
                });
                
                return this.explosionProgress < 30;
            }
            
            // Normal movement
            this.moveTimer--;
            
            if (this.moveTimer <= 0) {
                const distance = 40 + Math.random() * 80;
                this.angle += (Math.random() - 0.5) * Math.PI * 0.6;
                this.targetX = this.x + Math.cos(this.angle) * distance;
                this.targetY = this.y + Math.sin(this.angle) * distance;
                
                this.targetX = Math.max(40, Math.min(canvas.width - 40, this.targetX));
                this.targetY = Math.max(40, Math.min(canvas.height - 40, this.targetY));
                
                this.moveTimer = 25 + Math.random() * 50;
            }
            
            const dx = this.targetX - this.x;
            const dy = this.targetY - this.y;
            this.x += dx * 0.04;
            this.y += dy * 0.04;
            
            this.trianglePhase += 0.08;
            this.pulsePhase += this.pulseSpeed;
            
            // Check if should explode
            if (this.pulsePhase >= this.maxPulse) {
                this.isExploding = true;
            }
            
            return true;
        }
        
        draw() {
            if (this.isExploding) {
                // Draw explosion bubbles
                ctx.strokeStyle = '#bbb';
                ctx.lineWidth = 0.8;
                this.explosionBubbles.forEach(bubble => {
                    ctx.globalAlpha = bubble.life / 30;
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
                return;
            }
            
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1.2;
            
            const size = 12;
            const triangleOffset = 6 + Math.sin(this.trianglePhase) * 1.5;
            
            // Draw outer circle
            ctx.beginPath();
            ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw pulsing center dot (red to green)
            const pulseProgress = this.pulsePhase / this.maxPulse;
            const r = Math.floor(220 - pulseProgress * 140);
            const g = Math.floor(20 + pulseProgress * 215);
            ctx.fillStyle = `rgb(${r}, ${g}, 20)`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 3.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw four triangles
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2);
                const tx = this.x + Math.cos(angle) * triangleOffset;
                const ty = this.y + Math.sin(angle) * triangleOffset;
                
                ctx.beginPath();
                ctx.moveTo(tx + Math.cos(angle) * 3, ty + Math.sin(angle) * 3);
                ctx.lineTo(tx + Math.cos(angle + Math.PI * 2/3) * 3, 
                          ty + Math.sin(angle + Math.PI * 2/3) * 3);
                ctx.lineTo(tx + Math.cos(angle - Math.PI * 2/3) * 3, 
                          ty + Math.sin(angle - Math.PI * 2/3) * 3);
                ctx.closePath();
                ctx.stroke();
            }
        }
    }
    
    // Bubble class
    class Bubble {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.radius = Math.random() * 3 + 1.5;
            this.speedY = -0.25 - Math.random() * 0.4;
            this.speedX = (Math.random() - 0.5) * 0.25;
        }
        
        update() {
            this.y += this.speedY;
            this.x += this.speedX;
            
            if (this.y < -10) {
                this.y = canvas.height + 10;
                this.x = Math.random() * canvas.width;
            }
        }
        
        draw() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
    
    // Initialize game
    const creature = new Creature();
    
    for (let i = 0; i < 18; i++) {
        game.bubbles.push(new Bubble());
    }
    
    // Spawn food based on difficulty
    function spawnFood() {
        const maxFood = Math.min(5, Math.floor(game.difficulty) + 1);
        if (game.foods.length < maxFood) {
            game.foods.push(new Food());
        }
    }
    
    spawnFood(); // Start with one food
    
    // Touch/mouse controls
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        game.targetX = touch.clientX;
        game.targetY = touch.clientY;
    });
    
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        game.targetX = touch.clientX;
        game.targetY = touch.clientY;
    });
    
    canvas.addEventListener('click', (e) => {
        game.targetX = e.clientX;
        game.targetY = e.clientY;
    });
    
    function checkCollision(obj1, obj2, distance) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        return Math.sqrt(dx * dx + dy * dy) < distance;
    }
    
    // Game loop
    function gameLoop() {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        game.bubbles.forEach(bubble => {
            bubble.update();
            bubble.draw();
        });
        
        // Update and draw waves
        game.waves = game.waves.filter(wave => {
            const alive = wave.update();
            
            // Check collision with creature
            if (wave.isRed() && creature.checkWaveCollision(wave)) {
                creature.shrink();
                return false;
            }
            
            if (alive) wave.draw();
            return alive;
        });
        
        // Update and draw foods
        game.foods = game.foods.filter((food, index) => {
            const alive = food.update();
            if (alive) food.draw();
            
            if (!food.isExploding) {
                const head = creature.getHeadPosition();
                if (checkCollision(head, food, 18)) {
                    creature.grow();
                    return false;
                }
            }
            
            return alive;
        });
        
        // Spawn new food
        if (Math.random() < 0.02) spawnFood();
        
        creature.update(game.targetX, game.targetY);
        creature.draw();
        
        requestAnimationFrame(gameLoop);
    }
    
    gameLoop();
</script>
```

</body>
</html>
